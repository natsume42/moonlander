#include "ctrl_dance.h"
#include "custom_actions.h"

static uint8_t  ctrl_dance_keycode;
static uint16_t ctrl_dance_start_time;

void reset_ctrl_dance(void) {
    ctrl_dance_keycode    = 0;
    ctrl_dance_start_time = 0;
}

// clang-format off
bool within_tapping_term(uint16_t time, uint8_t keycode) {
    return time - ctrl_dance_start_time < get_tapping_term(CD(keycode), NULL);
}
// clang-format on

bool is_same_dancer(uint8_t keycode, uint16_t time) {
    return ctrl_dance_start_time > 0 &&
           ctrl_dance_keycode == keycode
           /* If time is same, event has not been generated by a human user (dancer),
            * but by the firmware itself, e.g. because of a layer switch during an OSL action.
            * Since we want ctrl dances to be usable also in OSL contexts, we only accept
            * events with higher timestamps.
            */
           && ctrl_dance_start_time < time;
}

void process_ctrl_dance(uint8_t keycode, keyrecord_t *record) {
    if (record->event.pressed) {
        ctrl_dance_start_time = record->event.time;
        ctrl_dance_keycode    = keycode;
    } else if (is_same_dancer(keycode, record->event.time)) {
        if (within_tapping_term(record->event.time, ctrl_dance_keycode)) {
            tap_code16(ctrl_dance_keycode);
        } else {
            tap_code16(LCTL(ctrl_dance_keycode));
        }
        reset_ctrl_dance();
    }
}

bool is_dance_interrupt(int8_t keycode) { return keycode != ctrl_dance_keycode && ctrl_dance_keycode != 0; }

void interrupt_ctrl_dance_on_different_key(uint8_t keycode) {
    if (is_dance_interrupt(keycode)) {
        tap_code16(ctrl_dance_keycode);
        reset_ctrl_dance();
    }
}
